import { Card, Tabs } from "@mintlify/components";
import { Tab } from "@headlessui/react";

### Prompt the LLM to build your tool

<Tabs>
  <Tab title="Vercel AI SDK" icon="/images/vercel.svg">
    <Card>
      Copy this prompt to build the Vercel AI SDK tool:
      ```markdown Vercel AI SDK Agent Prompt expandable
      ## Vercel AI SDK: Sales Agent (BuildKit + Pica)

      This agent automates lead qualification and follow‑up using Gmail, Attio, and Slack via Pica. It is triggered by sending `/sales` in the chat.

      ## Critical Integration Rules
      - Do not hard-code API paths, HTTP methods, content types, or action IDs.
      - Always discover action contracts at runtime using Pica MCP utilities:
      1) list available actions for a platform
      2) fetch action knowledge for the chosen action (method, path template, params, content-type, pagination, rate limits, examples)
      - Build requests using the discovered contract with `picaToolExecutor` (passthrough), not static values.
      - Validate required environment variables at runtime and fail fast if missing.

      ### Discovery Flow (per tool call)
      1. Use Pica to list platform actions (e.g., gmail, attio, slack).
      2. Select the specific action by title/key (e.g., "List User Messages", "Get Message", "Create Draft", "List Objects", "List Attributes", "Create Attribute", "Assert Person Record", "chat.postMessage").
      3. Use action knowledge to derive method, path, query/body schema, and content type.
      4. Execute via `picaToolExecutor` using the derived values.

      ### Tools
      0) listAttioObjects
      - Purpose: List all Attio objects and dynamically resolve the correct People-like object identifier (slug/ID) instead of hardcoding "people".
      - Strategy: Prefer exact slug match for `people`; else case-insensitive match on title/slug containing "people"; else ask user or fail with a clear message.
      - Discovery: Resolve Attio action for "List Objects" at runtime and use returned identifiers in subsequent calls.

      1) fetchLeadEmails
      - Purpose: Fetch Gmail emails from the last 24 hours with sales keywords.
      - Filter: `after:YYYY/MM/DD` and keywords: "demo request", "pricing", "trial", "partnership", "interested" in subject or body.
      - Discovery: Resolve Gmail action for "List User Messages" at runtime; apply `q` and `maxResults` per the action contract.

      2) getGmailMessage
      - Purpose: Load full Gmail message details by id.
      - Discovery: Resolve Gmail action for "Get Message" at runtime; include `format=full` and `metadataHeaders` as supported.

      3) verifyAttioAttributes
      - Purpose: Ensure required People attributes exist in Attio; create missing ones automatically before any upserts.
      - Dynamic object selection: Use `listAttioObjects` to determine the correct People object identifier; then list/create attributes on that identifier.
      - Discovery:
      - Resolve Attio action for "List Attributes" on the resolved object identifier.
      - Resolve Attio action for "Create Attribute" on the resolved object identifier.
      - Required attributes and slug/type mapping (logical intent, not hard-coded contract):
      - Name → `name` (personal-name; usually system-provided)
      - Email → `email_addresses` (email-address; system)
      - Company → `company` (record-reference; config.allowed_objects: ["companies"])
      - Role → `title` (text)
      - Message → `description` (text)
      - Lead Score → `lead-score` (text)
      - Source → `source` (text)
      - Created Date → `created-date` (timestamp)
      - Creation must satisfy fields required by the discovered contract (description, flags, default_value with required `template`, and `config`).

      4) extractLeadDetails
      - Purpose: Parse and structure lead info from email body.
      - Output: `{ name?, email?, company?, role?, message }`
      - Behavior: Uses GPT extraction; handles signatures/forwards; falls back to raw body.

      5) upsertAttioPerson
      - Purpose: Create/update contact in Attio with lead details and score.
      - Discovery: Resolve Attio action for "Assert Person Record" at runtime and upsert with `matching_attribute=email_addresses` (use discovered query schema).
      - Body keys: `name`, `email_addresses`, `company` (domains or record id), `title` (role), `description` (message), `lead-score`, `source`, `created-date`.

      6) scoreLead
      - Purpose: Classify the lead as Hot / Warm / Cold using GPT.
      - Criteria:
      - Hot: explicit demo/pricing/call ASAP, strong buying signals
      - Warm: general interest, exploring, timeline soon
      - Cold: vague, non-buyer, unrelated

      7) postSlackNotification
      - Purpose: Post a structured message to Slack channel with lead details and suggested next steps.
      - Discovery: Resolve Slack action for `chat.postMessage` at runtime; send `{ channel, text, blocks }` according to the contract.

      8) generateEmailDraft
      - Purpose: Generate a personalized reply and create a Gmail draft.
      - Discovery: Resolve Gmail action for "Create Draft" at runtime; submit `{ message: { raw: base64url(RFC822) } }` if required by the contract.

      ## Attio Database Structure
      - Contacts
      - Name (Text)
      - Email (Email)
      - Company (Text)
      - Role (Text)
      - Message (Rich Text)
      - Lead Score (Select: Hot, Warm, Cold)
      - Source (Default: Gmail)
      - Created Date (Date)

      Note: Attio attributes use snake_case. Mappings used by the agent:
      - Role → `title`
      - Message → `description`
      - Lead Score → `lead_score`
      - Source → `source`
      - Created Date is automatic; do not set explicitly.

      ## Workflow
      1. Resolve People object identifier via `listAttioObjects`.
      2. Verify attributes on that object; create missing ones (via discovered Attio actions).
      3. Fetch new inbound sales-related emails from Gmail (last 24 hours, keywords; via discovered Gmail actions).
      4. For each message:
      - Load full message and extract a clean text body.
      - Extract lead details (name/email/company/role/message) with GPT.
      - If email missing, derive from `From` header.
      - Score the lead (Hot/Warm/Cold) with GPT.
      - Upsert contact in Attio using discovered Assert Person contract.
      - Post Slack notification to the configured channel with suggested next steps.
      - Generate a tailored Gmail draft reply.

      ## Environment Variables
      - `PICA_API_KEY`
      - `OPENAI_API_KEY`
      - `GMAIL_CONNECTION_KEY`
      - `ATTIO_CONNECTION_KEY`
      - `SLACK_CONNECTION_KEY`
      - `SLACK_CHANNEL_ID`

      ## Intelligent Behavior
      - Detect intent: pricing, demo request, partnership, general interest.
      - Assign score: Hot (immediate follow-up), Warm (nurture), Cold (archive/low priority).
      - Suggest next steps in Slack per score:
      - Hot: schedule demo, share pricing deck, propose times <24h
      - Warm: product overview, case studies, propose call this week
      - Cold: thank you + resources, reminder to follow up later
      - Prevent duplicates via Attio Assert (merge on email).
      - Robust error handling, retries, and logging.

      ## Implementation Notes
      - Command trigger: User sends `/sales` to run the workflow.
      - Message parsing: Support `content` (string | array), `parts` (array), or `text` fields to read user input robustly.
      - Chat response: For `/sales`, stream a proper assistant message to the UI using `toUIMessageStreamResponse()` (not a plain JSON Response).
      - Pica executor: Use a centralized helper that accepts `{ path, method, query/body, contentType }` derived from action knowledge (no hard-coded values).
      - Gmail filters: Always pass filtering via `q` (date + keywords) and limit with `maxResults` as supported by discovered contract.
      - Gmail body extraction: Prefer `payload.body.data` then walk parts for `text/plain`; fallback to `snippet`.
      - Draft creation: Build an RFC822 message and Base64URL-encode into `message.raw` if required by the discovered contract.
      - Attio attributes: Verify/create before upsert with safe defaults, correct `default_value.template`, and required `description` on the dynamically-resolved People object identifier.

      ## Security & Limits
      - Fail fast if required env vars are missing.
      - Do not print secrets.
      - Respect Gmail and Slack rate limits; keep message sizes reasonable.

      ## Invocation
      - Development chat UI: send `/sales` to execute.
      - Output: A streamed assistant message summarizing processed messages and per-lead results, with Slack posts sent and Gmail drafts created.
      ```
    </Card>
  </Tab>
  <Tab title="LangChain" icon="/images/langchain-icon.svg">
    <Card>
      Copy this prompt to build the LangChain tool:
      ```markdown LangChain Tool Suite expandable
      ## LangChain Tool Suite: Sales Agent (BuildKit + Pica)

      This LangChain Tool Suite automates lead qualification and follow‑up using Gmail, Attio, and Slack via Pica.

      ## Critical Integration Rules
      - Do not hard-code API paths, HTTP methods, content types, or action IDs.
      - Always discover action contracts at runtime using Pica MCP utilities:
      1) list available actions for a platform
      2) fetch action knowledge for the chosen action (method, path template, params, content-type, pagination, rate limits, examples)
      - Build requests using the discovered contract with a shared `picaToolExecutor` (passthrough), not static values.
      - Validate required environment variables at runtime and fail fast if missing.

      ### Discovery Flow (per tool call)
      1. Use Pica to list platform actions (e.g., gmail, attio, slack).
      2. Select the specific action by title/key (e.g., "List User Messages", "Get Message", "Create Draft", "List Objects", "List Attributes", "Create Attribute", "Assert Person Record", "chat.postMessage").
      3. Use action knowledge to derive method, path, query/body schema, and content type.
      4. Execute via `picaToolExecutor` using the derived values.

      ### Tools
      0) listAttioObjects
      - Purpose: List all Attio objects and dynamically resolve the correct People-like object identifier (slug/ID) instead of hardcoding "people".
      - Strategy: Prefer exact slug match for `people`; else case-insensitive match on title/slug containing "people"; else ask user or fail with a clear message.

      1) fetchLeadEmails
      - Purpose: Fetch Gmail emails from the last 24 hours with sales keywords.
      - Filter: `after:YYYY/MM/DD` and keywords: "demo request", "pricing", "trial", "partnership", "interested" in subject or body.

      2) getGmailMessage
      - Purpose: Load full Gmail message details by id.

      3) verifyAttioAttributes
      - Purpose: Ensure required People attributes exist in Attio; create missing ones automatically before any upserts.
      - Dynamic object selection: Use `listAttioObjects` to determine the correct People object identifier; then list/create attributes on that identifier.
      - Required attributes and slug/type mapping:
      - Name → `name` (personal-name; usually system-provided)
      - Email → `email_addresses` (email-address; system)
      - Company → `company` (record-reference; config.allowed_objects: ["companies"])
      - Role → `title` (text)
      - Message → `description` (text)
      - Lead Score → `lead_score` (text)
      - Source → `source` (text)
      - Created Date is automatic; do not set explicitly.

      4) extractLeadDetails
      - Purpose: Parse and structure lead info from email body.
      - Output: `{ name?, email?, company?, role?, message }`
      - Behavior: Uses an LLM extraction; handles signatures/forwards; falls back to raw body.

      5) upsertAttioPerson
      - Purpose: Create/update contact in Attio with lead details and score.
      - Query: include `matching_attribute=email_addresses` as required by discovered schema.
      - Body keys: `name`, `email_addresses`, `company` (domains or record id), `title` (role), `description` (message), `lead_score`, `source`.

      6) scoreLead
      - Purpose: Classify the lead as Hot / Warm / Cold using an LLM.

      7) postSlackNotification
      - Purpose: Post a structured message to Slack channel with lead details and suggested next steps.

      8) generateEmailDraft
      - Purpose: Generate a personalized reply and create a Gmail draft.

      ## Attio Database Structure
      - Contacts
      - Name (Text)
      - Email (Email)
      - Company (Text)
      - Role (Text)
      - Message (Rich Text)
      - Lead Score (Select: Hot, Warm, Cold)
      - Source (Default: Gmail)
      - Created Date (Date)

      Note: Attio attributes use snake_case. Mappings used by the suite:
      - Role → `title`
      - Message → `description`
      - Lead Score → `lead_score`
      - Source → `source`
      - Created Date is automatic; do not set explicitly.

      ## Workflow
      1. Resolve People object identifier via `listAttioObjects`.
      2. Verify attributes on that object; create missing ones.
      3. Fetch new inbound sales-related emails from Gmail (last 24 hours, keywords).
      4. For each message: extract body, parse lead details, derive missing email from headers if needed, score, upsert in Attio, post Slack notification, create Gmail draft.

      ## Environment Variables
      - `PICA_API_KEY`
      - `OPENAI_API_KEY`
      - `GMAIL_CONNECTION_KEY`
      - `ATTIO_CONNECTION_KEY`
      - `SLACK_CONNECTION_KEY`
      - `SLACK_CHANNEL_ID`

      ## Implementation Notes
      - Use `picaToolExecutor` with dynamically discovered `{ path, method, query/body, contentType }`.
      - If a full URL is returned by discovery, extract and use only its pathname as the passthrough path.
      - Apply Gmail `q` and `maxResults` correctly; extract Gmail body by preferring `payload.body.data`, then walking parts; fallback to `snippet`.
      - Upserts use `matching_attribute=email_addresses` and snake_case attribute slugs.
      - Handle errors and rate limits gracefully.
      ```
    </Card>
  </Tab>
  <Tab title="MCP Server" icon="/images/model-context-protocol.svg">
    <Card>
      Copy this prompt to build a the MCP server tool:
      ```markdown MCP Server expandable
      ## MCP Server: Sales Agent Tools (BuildKit + Pica)

      This MCP server exposes tools to automate lead qualification and follow‑up using Gmail, Attio, and Slack via Pica.

      ## Critical Integration Rules
      - Do not hard-code API paths, HTTP methods, content types, or action IDs.
      - Always discover action contracts at runtime using Pica MCP utilities:
      1) list available actions for a platform
      2) fetch action knowledge for the chosen action (method, path template, params, content-type, pagination, rate limits, examples)
      - Build requests using the discovered contract with a shared `picaToolExecutor` (passthrough), not static values.
      - Validate required environment variables at runtime and fail fast if missing.

      ### Discovery Flow (per tool call)
      1. Use Pica to list platform actions (e.g., gmail, attio, slack).
      2. Select the specific action by title/key (e.g., "List User Messages", "Get Message", "Create Draft", "List Objects", "List Attributes", "Create Attribute", "Assert Person Record", "chat.postMessage").
      3. Use action knowledge to derive method, path, query/body schema, and content type.
      4. Execute via `picaToolExecutor` using the derived values.

      ### Tools (MCP)
      - list_attio_objects
      - fetch_lead_emails
      - get_gmail_message
      - verify_attio_attributes
      - extract_lead_details
      - upsert_attio_person
      - score_lead
      - post_slack_notification
      - generate_email_draft

      Tool behaviors mirror the Vercel/LangChain specs:
      - `list_attio_objects`: resolve People-like object identifier dynamically (prefer slug `people`, else contains "people").
      - `fetch_lead_emails`: last 24h, apply `q` and `maxResults` via contract.
      - `get_gmail_message`: load full message with `format=full`, `metadataHeaders` as supported.
      - `verify_attio_attributes`: list/create attributes on the resolved object identifier; required slugs: `title`, `description`, `lead_score`, `source`, `company` (record-reference).
      - `extract_lead_details`: parse `{ name?, email?, company?, role?, message }` using an LLM.
      - `upsert_attio_person`: upsert with `matching_attribute=email_addresses`; body keys include `name`, `email_addresses`, `company`, `title`, `description`, `lead_score`, `source`.
      - `score_lead`: Hot/Warm/Cold classification.
      - `post_slack_notification`: post structured summary + next steps to channel.
      - `generate_email_draft`: create Gmail draft from RFC822 base64url `message.raw`.

      ## Attio Database Structure
      - Contacts
      - Name (Text)
      - Email (Email)
      - Company (Text)
      - Role (Text)
      - Message (Rich Text)
      - Lead Score (Select: Hot, Warm, Cold)
      - Source (Default: Gmail)
      - Created Date (Date)

      Note: Attio attributes use snake_case. Mappings used by the server:
      - Role → `title`
      - Message → `description`
      - Lead Score → `lead_score`
      - Source → `source`
      - Created Date is automatic; do not set explicitly.

      ## Workflow (Suggested Orchestration Tool)
      1. Resolve People object identifier via `list_attio_objects`.
      2. Verify attributes on that object; create missing ones.
      3. Fetch new inbound sales-related emails from Gmail (last 24 hours, keywords).
      4. For each message: extract body, parse lead details, derive missing email from headers if needed, score, upsert in Attio, post Slack notification, create Gmail draft.

      ## Environment Variables
      - `PICA_API_KEY`
      - `OPENAI_API_KEY`
      - `GMAIL_CONNECTION_KEY`
      - `ATTIO_CONNECTION_KEY`
      - `SLACK_CONNECTION_KEY`
      - `SLACK_CHANNEL_ID`

      ## Implementation Notes
      - Provide strict input schemas (zod) per tool.
      - Use `picaToolExecutor` with dynamically discovered `{ path, method, query/body, contentType }`.
      - If a full URL is returned by discovery, extract and use only its pathname as the passthrough path.
      - Apply Gmail `q` and `maxResults` correctly; extract Gmail body by preferring `payload.body.data`, then walking parts; fallback to `snippet`.
      - Upserts use `matching_attribute=email_addresses` and snake_case attribute slugs.
      - Handle errors and rate limits gracefully and return structured MCP responses.
      ```
    </Card>
  </Tab>
</Tabs>
